const fs = require('fs');
const path = require('path');
const Rand = require('./Rand');

class DatabaseReader {
    constructor(contentPath) {
        this.contentPath = contentPath;
        this.files = [
            'ability', 'actor', 'animation', 'biome', 'difficulty', 
            'equipment', 'gender', 'item', 'job', 'monster', 'passive', 
            'recipe', 'spark', 'status', 'system', 'troop', 'voxel'
        ];
    
        this.databases = {};
    }

    readFiles() {
        // Reads the database files into memory.
        // The database files are plaintext JSON files containing arrays of objects related to the database.
        // They are all encoded on disk by modifying every bit to be 255 - <value> in the file.
        for(const file of this.files) {
            const data = fs.readFileSync(path.join(this.contentPath, 'Database', file + '.dat'));
            const header = data.slice(0, 2);
            const arr = new Uint8Array(data.slice(2));
            const end = arr.length;

            let i = 0;
            while(i < end) {
                arr[i] = 255 - arr[i];
                i++;
            }

            const json = JSON.parse(Buffer.from(arr).toString());

            this.databases[file] = {
                name: file,
                header: header,
                json: json,
            } 
        }
    }

    writeFiles() {
        for(let file in this.databases) {
            const data = this.databases[file];
            const arr = new Uint8Array(Buffer.from(JSON.stringify(data.json)));
            const end = arr.length;

            let i = 0;
            while(i < end) {
                arr[i] = 255 - arr[i];
                i++;
            }

            const datFile = Buffer.concat([data.header, Buffer.from(arr)]);
            fs.writeFileSync(path.join(this.contentPath, 'Database', file + '.dat'), datFile)
        }
    }

    fixItemPrices(itemMap) {
        // This is used to fix item prices after the shop items are swapped so that the swapped item
        // has the old items price. Uses the map generated by the shuffle shop method.
        for(let key in itemMap) {
            let newItem = itemMap[key]    // Obj with LootType LootValue keys
            let oldItem = key.split(','); // LootType,LootValue string
            let oldPrice = 0;
            let oldDatabase = [];
            let newDatabase = [];
            if (parseInt(oldItem[0]) === 1) {
                oldDatabase = this.databases.item.json;
            } else if (parseInt(oldItem[0]) === 2) {
                oldDatabase = this.databases.equipment.json;
            }

            // Retrieve price of old item
            for(let thing of oldDatabase) {
                if(thing && thing.ID === parseInt(oldItem[1])) {
                    oldPrice = thing.Cost;
                    break;
                }
            }

            if (newItem.LootType === 1) {
                newDatabase = this.databases.item.json;
            } else if (newItem.LootType === 2) {
                newDatabase = this.databases.equipment.json;
            }

            // Set price of new item in database
            for(let thing of newDatabase) {
                if(thing && thing.ID === newItem.LootValue) {
                    thing.Cost = oldPrice;
                }
            }
        }
    }

    shuffleMonsterDrops() {
        // Retrieves all monster drops from the monster database
        let allMonsterDrops = [];
        for(let monster of this.databases.monster.json) {
            if(monster && monster.ItemDrops) {
                for(let drop of monster.ItemDrops) {
                    allMonsterDrops.push(drop);
                }
            }
        }

        allMonsterDrops = Rand.shuffle(allMonsterDrops);

        // Shuffles those drops into the monster tables, the same number of drops is kept per monster.
        for(let monster of this.databases.monster.json) {
            if(monster && monster.ItemDrops) {
                const numDrops = monster.ItemDrops.length;

                monster.ItemDrops = [];
                for(let i = 0; i < numDrops; i++) {
                    monster.ItemDrops.push(allMonsterDrops.shift());
                }
            }
        }
    }

    shuffleMonsterSteals() {
        // Retrieves all monster steals from the monster database
        let allMonsterSteals = [];
        for(let monster of this.databases.monster.json) {
            if(monster && monster.ItemSteals) {
                for(let drop of monster.ItemSteals) {
                    allMonsterSteals.push(drop);
                }
            }
        }

        allMonsterSteals = Rand.shuffle(allMonsterSteals);

        // Shuffles those drops into the monster tables, the same number of steals is kept per monster.
        for(let monster of this.databases.monster.json) {
            if(monster && monster.ItemSteals) {
                const numDrops = monster.ItemSteals.length;

                monster.ItemSteals = [];
                for(let i = 0; i < numDrops; i++) {
                    monster.ItemSteals.push(allMonsterSteals.shift());
                }
            }
        }
    }

    getJobIds() {
        const jobs = this.databases.job.json;
        return jobs.map((job) => job.ID)
    }

    getMapIds() {
        const items = this.databases.item.json;
        return items.filter((item) => item && item.MapForBiomeID !== null).map((item) => item.ID)
    }

    getBossTroops() {
        let bossMonsters = [];
        let bossTroops = {};
        for(let monster of this.databases.monster.json) {
            if(monster.IsBoss) {
                for(let troop of this.databases.troop.json) {
                    for(let troopMonster of troop.Members) {
                        if (monster.ID === troopMonster.MonsterID) {
                            bossTroops[troop.ID] = true;
                            break;
                        }
                    }
                };
            }
        }

        return Object.keys(bossTroops).map((x) => parseInt(x)); // JS makes keys strings if they are ints
    }

    scaleTroopStats(troopMap) {
        // The idea behind this is pretty basic, we assume stats scale linearly
        // So we take one of the original troops and get their level
        // then take the newTroop and get their level, and scale it based off of newLevel/oldLevel
        // idc that this is highly inefficient, the arrays arent that big

        const troopsToScale = [];
        for(let troopSet of troopMap) {
            const oldTroopSet = troopSet[0];
            let maxOldLevel = -1;
            let maxNewLevel = -1;

            for(let oldTroop of oldTroopSet) {
                // From the old monsters we want to grab the highest level monster in any of the troops and scale the whole instance by that
                if (oldTroop) {
                    // Find the old troop in the database
                    for(let troop of this.databases.troop.json) {
                        if (troop.ID === oldTroop.TroopID) {
                            for(let oldMonster of troop.Members) {
                                if (oldMonster) {
                                    for(let monster of this.databases.monster.json) {
                                        if (monster.ID === oldMonster.MonsterID) {
                                            if(monster.Level > maxOldLevel) {
                                                maxOldLevel = monster.Level;
                                            }
                                            break;
                                        }
                                    }
                                }
                            }
                            break;
                        }
                    }
                }
            }

            let newTroopSet = troopSet[1];
            if (!Array.isArray(newTroopSet)) {
                newTroopSet = [newTroopSet]
            };

            for(let newTroop of newTroopSet) {
                // From the old monsters we want to grab the highest level monster in any of the troops and scale the whole instance by that
                if (newTroop) {
                    // Find the old troop in the database
                    for(let troop of this.databases.troop.json) {
                        if (troop.ID === newTroop.TroopID) {
                            for(let oldMonster of troop.Members) {
                                if (oldMonster) {
                                    for(let monster of this.databases.monster.json) {
                                        if (monster.ID === oldMonster.MonsterID) {
                                            if(monster.Level > maxNewLevel) {
                                                maxNewLevel = monster.Level;
                                            }
                                            break;
                                        }
                                    }
                                }
                            }
                            break;
                        }
                    }
                }
            }

            // So now we store these in the map, we do this because if we edit it right now, it may affect future swap inquiries
            // e.g. if A <-> B Swap and B <-> C swap and we save B, that will change Cs result
            if (maxOldLevel !== -1 && maxNewLevel !== -1) {
                troopsToScale.push({ scale: maxOldLevel/maxNewLevel, troops: newTroopSet});
            }
        }

        for(let troopInfo of troopsToScale) {
            for(let scaleTroop of troopInfo.troops) {
                for(let troop of this.databases.troop.json) {
                    if (troop.ID === scaleTroop.TroopID) {
                        for(let troopMonster of troop.Members) {
                            for(let monster of this.databases.monster.json) {
                                if (monster.ID === troopMonster.MonsterID) {
                                    monster.Level = Math.round(monster.Level * troopInfo.scale);
                                    monster.Exp = Math.round(monster.Exp * troopInfo.scale);
                                    monster.HP = Math.round(monster.HP * troopInfo.scale);
                                    monster.MP = Math.round(monster.MP * troopInfo.scale);
                                    monster.Str = Math.round(monster.Str * troopInfo.scale);
                                    monster.Vit = Math.round(monster.Vit * troopInfo.scale);
                                    monster.Dex = Math.round(monster.Dex * troopInfo.scale);
                                    monster.Agi = Math.round(monster.Agi * troopInfo.scale);
                                    monster.Mnd = Math.round(monster.Mnd * troopInfo.scale);
                                    monster.Spi = Math.round(monster.Spi * troopInfo.scale);
                                    monster.Spd = Math.round(monster.Spd * troopInfo.scale);
                                    monster.Lck = Math.round(monster.Lck * troopInfo.scale);
                                    monster.PAtk = Math.round(monster.PAtk * troopInfo.scale);
                                    monster.PDef = Math.round(monster.PDef * troopInfo.scale);
                                    monster.MDef = Math.round(monster.MDef * troopInfo.scale);
                                    break;
                                }
                            }
                        }
                        break;
                    }
                }
            }
        }
    }

}

module.exports = DatabaseReader;