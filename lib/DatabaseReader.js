const fs = require('fs');
const path = require('path');
const Rand = require('./Rand');

class DatabaseReader {
    constructor(contentPath) {
        this.contentPath = contentPath;
        this.files = [
            'ability', 'actor', 'animation', 'biome', 'difficulty', 
            'equipment', 'gender', 'item', 'job', 'monster', 'passive', 
            'recipe', 'spark', 'status', 'system', 'troop', 'voxel'
        ];
    
        this.databases = {};
    }

    readFiles() {
        // Reads the database files into memory.
        // The database files are plaintext JSON files containing arrays of objects related to the database.
        // They are all encoded on disk by modifying every bit to be 255 - <value> in the file.
        for(const file of this.files) {
            const data = fs.readFileSync(path.join(this.contentPath, 'Database', file + '.dat'));
            const header = data.slice(0, 2);
            const arr = new Uint8Array(data.slice(2));
            const end = arr.length;

            let i = 0;
            while(i < end) {
                arr[i] = 255 - arr[i];
                i++;
            }

            const json = JSON.parse(Buffer.from(arr).toString());

            this.databases[file] = {
                name: file,
                header: header,
                json: json,
            } 
        }
    }

    writeFiles() {
        for(let file in this.databases) {
            const data = this.databases[file];
            const arr = new Uint8Array(Buffer.from(JSON.stringify(data.json)));
            const end = arr.length;

            let i = 0;
            while(i < end) {
                arr[i] = 255 - arr[i];
                i++;
            }

            const datFile = Buffer.concat([data.header, Buffer.from(arr)]);
            fs.writeFileSync(path.join(this.contentPath, 'Database', file + '.dat'), datFile)
        }
    }

    fixItemPrices(itemMap) {
        // This is used to fix item prices after the shop items are swapped so that the swapped item
        // has the old items price. Uses the map generated by the shuffle shop method.
        for(let key in itemMap) {
            let newItem = itemMap[key]    // Obj with LootType LootValue keys
            let oldItem = key.split(','); // LootType,LootValue string
            let oldPrice = 0;
            let oldDatabase = [];
            let newDatabase = [];
            if (parseInt(oldItem[0]) === 1) {
                oldDatabase = this.databases.item.json;
            } else if (parseInt(oldItem[0]) === 2) {
                oldDatabase = this.databases.equipment.json;
            }

            // Retrieve price of old item
            for(let thing of oldDatabase) {
                if(thing && thing.ID === parseInt(oldItem[1])) {
                    oldPrice = thing.Cost;
                    break;
                }
            }

            if (newItem.LootType === 1) {
                newDatabase = this.databases.item.json;
            } else if (newItem.LootType === 2) {
                newDatabase = this.databases.equipment.json;
            }

            // Set price of new item in database
            for(let thing of newDatabase) {
                if(thing && thing.ID === newItem.LootValue) {
                    thing.Cost = oldPrice;
                }
            }
        }
    }

    shuffleMonsterDrops() {
        // Retrieves all monster drops from the monster database
        let allMonsterDrops = [];
        for(let monster of this.databases.monster.json) {
            if(monster && monster.ItemDrops) {
                for(let drop of monster.ItemDrops) {
                    allMonsterDrops.push(drop);
                }
            }
        }

        allMonsterDrops = Rand.shuffle(allMonsterDrops);

        // Shuffles those drops into the monster tables, the same number of drops is kept per monster.
        for(let monster of this.databases.monster.json) {
            if(monster && monster.ItemDrops) {
                const numDrops = monster.ItemDrops.length;

                monster.ItemDrops = [];
                for(let i = 0; i < numDrops; i++) {
                    monster.ItemDrops.push(allMonsterDrops.shift());
                }
            }
        }
    }

    shuffleMonsterSteals() {
        // Retrieves all monster steals from the monster database
        let allMonsterSteals = [];
        for(let monster of this.databases.monster.json) {
            if(monster && monster.ItemSteals) {
                for(let drop of monster.ItemSteals) {
                    allMonsterSteals.push(drop);
                }
            }
        }

        allMonsterSteals = Rand.shuffle(allMonsterSteals);

        // Shuffles those drops into the monster tables, the same number of steals is kept per monster.
        for(let monster of this.databases.monster.json) {
            if(monster && monster.ItemSteals) {
                const numDrops = monster.ItemSteals.length;

                monster.ItemSteals = [];
                for(let i = 0; i < numDrops; i++) {
                    monster.ItemSteals.push(allMonsterSteals.shift());
                }
            }
        }
    }

    getJobIds() {
        const jobs = this.databases.job.json;
        return jobs.map((job) => job.ID)
    }

    getMapIds() {
        const items = this.databases.item.json;
        return items.filter((item) => item && item.MapForBiomeID !== null).map((item) => item.ID)
    }

}

module.exports = DatabaseReader;